package io.confluent.connect.custom.transforms;

import io.confluent.connect.custom.utils.FieldListJsonPathExtractor;
import org.apache.kafka.common.config.ConfigDef;
import org.apache.kafka.common.config.ConfigException;
import org.apache.kafka.connect.connector.ConnectRecord;
import org.apache.kafka.connect.data.Schema;
import org.apache.kafka.connect.data.SchemaBuilder;
import org.apache.kafka.connect.transforms.util.SimpleConfig;

import java.util.List;
import java.util.Map;

public class NestedValueToKeys<R extends ConnectRecord<R>> extends BaseNestedValue<R> {

    Schema keySchema = SchemaBuilder
            .map(Schema.STRING_SCHEMA, SchemaBuilder.string().optional().build())
            .doc("Schema generated by NestedValueToKeys SMT")
            .name("MAP_STRING_TO_ANY")
            .build();

    public interface ConfigName {
        String KEY_FIELD_MAPPING = "keyFieldMapping";
    }

    public static final ConfigDef CONFIG_DEF = new ConfigDef()
            .define(ConfigName.KEY_FIELD_MAPPING, ConfigDef.Type.LIST, null, ConfigDef.Importance.LOW,
                    "Map of key field name to json path in the message value. eg: field1:jsonpath1,field2:jsonpath2..");

    private static final String PURPOSE = "construct the record key from value and replaces them";
    private List<String> keyFieldList;
    private Map<String, String> keyFieldMap;
    private FieldListJsonPathExtractor keyFieldExtractor = null;

    @Override
    public void configure(Map<String, ?> props) {
        final SimpleConfig config = new SimpleConfig(CONFIG_DEF, props);
        keyFieldList = config.getList(NestedValueToKeys.ConfigName.KEY_FIELD_MAPPING);
        if (this.keyFieldList == null || this.keyFieldList.isEmpty()) {
            throw new ConfigException(
                    "`" + ConfigName.KEY_FIELD_MAPPING + "` is required for `" + getClass().getName() + "`"
            );
        }
        keyFieldMap = parseMappings(this.keyFieldList, ConfigName.KEY_FIELD_MAPPING);
        keyFieldExtractor = new FieldListJsonPathExtractor(keyFieldMap, ConfigName.KEY_FIELD_MAPPING);
    }

    @Override
    public R apply(R record) {
        Object messageValue = extractObject(record, PURPOSE);
        return record.newRecord(record.topic(), null, keySchema,
                keyFieldExtractor.extractValues(messageValue), record.valueSchema(),
                record.value(), record.timestamp(), record.headers());
    }

    @Override
    public ConfigDef config() {
        return CONFIG_DEF;
    }

}

