package io.confluent.connect.custom.transforms;

import io.confluent.connect.custom.utils.FieldListJsonPathExtractor;
import org.apache.kafka.common.config.ConfigDef;
import org.apache.kafka.common.config.ConfigException;
import org.apache.kafka.connect.connector.ConnectRecord;
import org.apache.kafka.connect.data.Schema;
import org.apache.kafka.connect.data.SchemaBuilder;
import org.apache.kafka.connect.data.Struct;
import org.apache.kafka.connect.transforms.util.SimpleConfig;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static org.apache.kafka.connect.transforms.util.Requirements.requireMap;
import static org.apache.kafka.connect.transforms.util.Requirements.requireStruct;

public class NestedValueToKeys<R extends ConnectRecord<R>> extends BaseNestedValue<R> {

    Schema keySchema =  SchemaBuilder
            .map(Schema.STRING_SCHEMA, SchemaBuilder.string().optional().build())
            .doc("Schema generated by NestedValueToKeys SMT")
            .name("MAP_STRING_TO_ANY")
            .build();

    public interface ConfigName {
        String KEY_FIELD_MAPPING = "keyFieldMapping";
    }

    public static final ConfigDef CONFIG_DEF = new ConfigDef()
            .define(ConfigName.KEY_FIELD_MAPPING, ConfigDef.Type.LIST, null, ConfigDef.Importance.LOW,
                    "Map of key field name to json path in the message body. eg: field1:jsonpath1,field2:jsonpath2..");

    private static final String PURPOSE = "construct the record key from value and replaces them";
    private List<String> keyFieldList;
    private Map<String, String> keyFieldMap;
    private FieldListJsonPathExtractor keyFieldExtractor = null;

    @Override
    public void configure(Map<String, ?> props) {
        final SimpleConfig config = new SimpleConfig(CONFIG_DEF, props);
        keyFieldList = config.getList(NestedValueToKeys.ConfigName.KEY_FIELD_MAPPING);
        if (this.keyFieldList == null || this.keyFieldList.isEmpty()) {
            throw new ConfigException(
                    "`" + ConfigName.KEY_FIELD_MAPPING + "` is required for `" + getClass().getName() + "`"
            );
        }
        keyFieldMap = parseMappings(this.keyFieldList, ConfigName.KEY_FIELD_MAPPING);
        keyFieldExtractor = new FieldListJsonPathExtractor(keyFieldMap, ConfigName.KEY_FIELD_MAPPING);
    }

    @Override
    protected R applySchemaless(R record) {
        final Map<String, Object> value = requireMap(record.value(), PURPOSE);
        Map<String, Object> keyData = new LinkedHashMap<>();
        for (Map.Entry<String, String> fieldItem : keyFieldMap.entrySet()) {
            keyData.put(fieldItem.getKey(), value.get(fieldItem.getValue()));
        }
        return record.newRecord(record.topic(), null, keySchema, keyData, record.valueSchema(), record.value(), record.timestamp(), record.headers());
    }

    @Override
    protected R applyWithSchema(R record) {
        final Struct value = requireStruct(record.value(), PURPOSE);
        return record.newRecord(record.topic(), null, null,
                keyFieldExtractor.extractValues(extractObject(record)),
                value.schema(), value, record.timestamp(), record.headers());
    }

    @Override
    public ConfigDef config() {
        return CONFIG_DEF;
    }

}

